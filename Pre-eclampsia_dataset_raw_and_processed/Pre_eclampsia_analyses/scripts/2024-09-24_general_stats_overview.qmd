---
title: "2024-09-24_general_stats_overview"
author: "Ioana Weber"
format: html
editor: visual
---

# Aim

Explore overlap between exons from the different datasets

# Preparations

## Install packages if needed

```{r}
#pacman::p_install(htmlwidgets) #pacman::p_install(rsconnect)
```

## Load packages, test for and resolve conflicts between functions of same name from different packages

```{r}
pacman::p_load(readxl,
               rlist,
               plotly,
               conflicted,
               tidyverse,
               ggplot2,
               readr,
               htmlwidgets,
               rsconnect,
               wrappedtools,
               RColorBrewer,
               UpSetR)

conflict_scout()
conflicts_prefer(dplyr::filter,
                 plotly::layout)
```

In case needing to re-set working directory:

```{r}
#setwd("C:/Win_Ubuntu_shared/Pre-eclampsia_dataset_raw_and_processed/Pre_eclampsia_analyses")
```

## If analysis performed previously: load results (uncomment as needed)

```{r}
# Load the variables from the RDS file
loaded_vars <- readRDS("./results/all_variables_general_stats.rds")
# Optionally, assign them back to the global environment
list2env(loaded_vars, envir = .GlobalEnv)
```

# Import and prepare results from Excel overview file

## Import

```{r}
general_stats <- read_excel("../Pre_eclampsia_mice_rnasplice_results/multiqc/2024-08-21_general_statistics_dataset.xlsx", sheet = "overview_simplified")

general_stats <- mutate(general_stats,
                        total_reads_millions = `FastQC_total_sequences_[millions]_R1`+`FastQC_total_sequences_[millions]_R2`,
                        total_duplicates_millions = `FasQC_%_duplicate_reads_R1`*`FastQC_total_sequences_[millions]_R1`+`FasQC_%_duplicate_reads_R2`*`FastQC_total_sequences_[millions]_R2`
                        )

# save as CSV
write.csv(general_stats, file = "./results/General_stats.csv", row.names = T )
```

## Pivot to long for plotting

```{r}
general_stats_long <- pivot_longer(general_stats,
                                   cols = c(total_reads_millions,
                                            total_duplicates_millions,
                                            STAR_M_Uniquely_mapped_reads,
                                            Salmon_M_mapped_reads),
                                   names_to = "Analysis Stage",
                                   values_to = "Reads (millions)") |>
  select(`Sample Name`, `Analysis Stage`, `Reads (millions)`)

# save as CSV
write.csv(general_stats_long, file = "./results/General_stats_long_form.csv", row.names = T )
```

# Sankey/alluvial plots to visualize how reads were used in the pipeline
## Test plot for one sample
```{r}
# test plot for one sample to make sure flow of info is correct in alluvial plot
 # extract data for this sample only
  CONTROL_REP1_data <- general_stats |>
    # filter for the row with this sample name
    filter(`Sample Name` == "CONTROL_REP1") |>
    # select which columns to include the data from
    select(`Sample Name` = `Sample Name`, 
           total_reads_millions = total_reads_millions,
           total_duplicates_millions = total_duplicates_millions,
           uniquely_mapped_reads_STAR = STAR_M_Uniquely_mapped_reads,
           mapped_reads_Salmon = Salmon_M_mapped_reads)
  
  # Pivot the sample data to long format for easier plotting and select relevant data only
  CONTROL_REP1_data_long <- CONTROL_REP1_data |>
    pivot_longer(cols = c(total_reads_millions,
                          total_duplicates_millions,
                          uniquely_mapped_reads_STAR,
                          mapped_reads_Salmon),
                 names_to = "Analysis Stage",
                 values_to = "Reads (millions)") |>
    select(`Sample Name`,
           `Analysis Stage`,
           `Reads (millions)`)
  
  # Create the alluvial plot using plotly
  CONTROL_REP1__plot <- plot_ly(
    type = "sankey",
    arrangement = "snap",
    
    # which info should be used as nodes (vertical bars) in the plot?
    node = list(
      label = c("Total Reads (FastQC)",
                "Duplicates (FastQC)",
                "Uniquely Mapped (STAR)",
                "Mapped Reads (Salmon)"
                ),
      texttemplate = "%{label}", # text to show by default next to the bar when nothing is hovered over
      hovertemplate = "Reads: %{value} × 10<sup>6</sup> reads<extra></extra>"  # get hover to only show reads in millions and no other info
      ),
    
    # how should the nodes be connected to one another?
    link = list(
      source = c(0, 0, 1, 2),  # Defining the flow between the stages (start at index 0, I suspect because Plotly is originally a Python package)
      target = c(1, 2, 2, 3),  # The target of each stage of the analysis
      value = c(sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "total_reads_millions"],
              sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "total_duplicates_millions"],
              sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "uniquely_mapped_reads_STAR"],
              sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "mapped_reads_Salmon"]
              ),
      # what to display when hovering over the connections between the bars. "<extra></extra>" ensures nothing other than the desired annotation appears on the plot.
      hovertemplate = "Reads: %{value} × 10<sup>6</sup> reads<extra></extra>"
      )
    )

  sample_plot
```
An interesting thing I noticed is that some of the numbers don't add up after looking at the general stats: even though I see that many reads are flagged as duplicates by FastQC, it seems that these aren't removed by default. It looks like STAR uses *absolutely all* reads that are present in the FastQ files, or else I can't explain why the sum of STAR-aligned reads and duplicates is higher than the total number of reads. To make the Sankey plots more easy to understand, I removed the info about the duplicates from most of them, but it's good to know that, for further analyses, I should look into the duplicates issue before proceeding with the pipeline.


## Create all of the alluvial plots in a loop
```{r}
# Define a custom color palette for nodes, flows, and labels
# # nodes are: total read count (node 0), aligned by STAR (node 1), mapped by Salmon (node 2), not aligned by STAR (node 3), not mapped by Salmon (node 4)
node_colors <- c("rgba(211,211,211, 1)", # node 0, total reads
                 "rgba(102,194,165, 1)",  # node 1, aligned by STAR
                 "rgba(141,160,203, 1)",  # node 2, mapped by Salmon
                 "rgba(229,216,189, 1)",  # node 3, not aligned by STAR
                 "rgba(255,255,204, 1)")  # node 4, not mapped by Salmon

# will be setting up the following links that I need colors for:
       ## total reads -> aligned by STAR (link nodes 0 to 1)
       ## total reads -> unaligned by STAR (link nodes 0 to 3)
       ## aligned by STAR -> mapped by Salmon (link nodes 1 to 2)
       ## aligned by STAR -> not mapped by Salmon (link nodes 1 to 4)
flow_colors <- c("rgba(102,194,165, 0.5)", # total reads -> aligned by STAR
                 "rgba(229,216,189, 0.5)", # total reads -> unaligned by STAR
                 "rgba(141,160,203, 0.5)", # aligned by STAR -> mapped by Salmon
                 "rgba(255,255,179, 0.75)" # aligned by STAR -> not mapped by Salmon 
                 )

# Define custom colors for each label using HTML styling
label_text <- c(
  "<span style='color:rgba(114,114,114, 1);'>Total Reads (FastQC)</span>",  # node 0
  "<span style='color:rgba(45,150,137, 1);'>Uniquely<br>Aligned<br>(STAR)</span>",  # node 1
  "<span style='color:rgba(55,89,195, 1);'>Mapped <br> (Salmon)</span>",  # node 2
  "<span style='color:rgba(197,168,108, 1);'>Not aligned by STAR/<br>not unique</span>",  # node 3
  "<span style='color:rgba(174,174,0, 1);'>Not mapped<br>by Salmon</span>"  # node 4
)

# Define an empty list to capture plots as they are created in the loop
plot_list <- list()

# loop through names of samples to create separate plot for each of them
for(sample_name in sample_list){
  
  # extract data for this sample only
  sample_data <- general_stats |>
    # filter for the row with this sample name
    filter(`Sample Name` == sample_name) |>
    # select which columns to include the data from
    select(`Sample Name` = `Sample Name`, 
           total_reads_millions = total_reads_millions,
           uniquely_mapped_reads_STAR = STAR_M_Uniquely_mapped_reads,
           mapped_reads_Salmon = Salmon_M_mapped_reads)
  
  # Pivot the sample data to long format for easier plotting and select relevant data columns only
  sample_data_long <- sample_data |>
    pivot_longer(cols = c(total_reads_millions,
                          uniquely_mapped_reads_STAR,
                          mapped_reads_Salmon),
                 names_to = "Analysis Stage",
                 values_to = "Reads (millions)") |>
    select(`Sample Name`,
           `Analysis Stage`,
           `Reads (millions)`)
  
  # Calculate unmapped reads as difference between total reads and uniquely mapped reads (need this for plotting so that Plotly is not confused about what's happening with the reads left from the total reads that were not mapped by STAR)
  unaligned_reads <- sample_data$total_reads_millions - sample_data$uniquely_mapped_reads_STAR
  unmapped_reads <- sample_data$uniquely_mapped_reads_STAR - sample_data$mapped_reads_Salmon
  
  # Create the alluvial plot using plotly
  sample_plot <- plot_ly(
    type = "sankey",
    arrangement = "snap",
    
    # which info should be used as nodes (vertical bars) in the plot?
    node = list(
      label = label_text,
      texttemplate = "%{label}", # text to show by default next to the bar when nothing is hovered over
      hovertemplate = "%{value} × 10<sup>6</sup> reads<extra></extra>",  # get hover to only show reads in millions and no other info
      color = node_colors,  # Set custom colors for the nodes
      
      # set custom positions for the nodes for a better aspect
      # # nodes are: total read count (node 0), aligned by STAR (node 1), mapped by Salmon (node 2), not aligned by STAR (node 3), not mapped by Salmon (node 4)
      x = c(0.1, # total read count (node 0)
            0.4, # aligned by STAR (node 1)
            0.9, # mapped by Salmon (node 2)
            0.9, # not aligned by STAR (node 3)
            0.9  # not mapped by Salmon (node 4)
            ),
      
      y = c(0.5, # total read count (node 0)
            0.2, # aligned by STAR (node 1)
            0.2, # mapped by Salmon (node 2)
            0.5, # not aligned by STAR (node 3)
            0.25 # not mapped by Salmon (node 4)
            ),
      
      # Control height of the nodes
      thickness = c(30, # total read count (node 0)
                    30, # aligned by STAR (node 1)
                    20, # mapped by Salmon (node 2)
                    20, # not aligned by STAR (node 3)
                    20 # not mapped by Salmon (node 4)
                    ),
      
       pad = 5  # Reduce vertical space between nodes by adjusting padding
      ),
    
    # how should the nodes be connected to one another?
    link = list(
      
      # Setting up the following links:
       ## total reads -> aligned by STAR (link nodes 0 to 1)
       ## total reads -> unaligned by STAR (link nodes 0 to 3)
       ## aligned by STAR -> mapped by Salmon (link nodes 1 to 2)
       ## aligned by STAR -> not mapped by Salmon (link nodes 1 to 4)

      source = c(0, 0, 1, 1),  # Defining the flow between the stages (start at index 0, I suspect because Plotly is originally a Python package). Go from 0 here (total reads) to 1 in target (uniquely mapped) and from 1 here (uniquely mapped) to 2 in target (mapped by Salmon)
      
      target = c(1, 3, 2, 4),  # The target of each stage of the analysis
      
      # the values indicate how thick the flows should be between the bars that represent the analysis stages
      value = c(#sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "total_reads_millions"],
              sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "uniquely_mapped_reads_STAR"],
              unaligned_reads,
              sample_data_long$`Reads (millions)`[sample_data_long$`Analysis Stage` == "mapped_reads_Salmon"],
              unmapped_reads
              ),
      # what to display when hovering over the connections between the bars. "<extra></extra>" ensures nothing other than the desired annotation appears on the plot.
      hovertemplate = "%{value} × 10<sup>6</sup> reads<extra></extra>",
      color = flow_colors  # Set custom colors for the flows
      )
    ) |>
    layout(
      title = list(
        text = paste0("Flow of Analyzed Reads for Sample: ", sample_name),
        font = list(size = 16)
        ),
      font = list(size = 12)
      )

  
  # append plot to plot list
  plot_list <- list.append(plot_list, sample_plot)
  
  # name the plot added last (position = length of list) as sample_name_alluvial
  names(plot_list)[length(plot_list)] <-
    paste0(sample_name, '_alluvial')
} 

plot_list[8]
```


# Save all variables from environment to an RDS file

```{r}
# Collect all variables from the global environment
all_vars_general_stats <- mget(ls(), envir = .GlobalEnv)

# Save the collected variables as an RDS file
saveRDS(all_vars_general_stats, file = "./results/all_vars_general_stats.rds")
```

# Copy results to Shiny app www folder

```{r}
# Define paths
source_folder <- "./plots"
destination_folder <- "./results/Shiny_app_rnasplice_results/www"

# Copy files from source to destination
file.copy(list.files(source_folder, full.names = TRUE), destination_folder, overwrite = TRUE)

```

# Deploy app ONLINE (uncomment when ready to publish)

```{r}
#rsconnect::deployApp('./results/Shiny_app_rnasplice_results')
```
